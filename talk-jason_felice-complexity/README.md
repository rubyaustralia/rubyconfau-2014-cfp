# Complexity Multipliers

Ever been on that project where you've been able to turn around a new feature
inside an hour?  And then the next project where it takes six weeks to turn
around a feature that feels just about the same size?  You rack your brain,
and when you try to figure out why, all you come up with is small stuff.
"Well, I guess we have to commit twice for a config change instead of once…"

I posit there are a class of things which are "complexity multipliers"–things
which seem small, but when a few of them get together, they have a major
impact on the velocity of the project.

The good thing is that complexity multipliers are easy to identify–if you
know what you are looking for.  They can be things inherent in the structure
of the code, in the development process, in the development tools.  I'd like
to show you some graphs and some common examples and define a conceptual
framework of how they affect projects.

## Jason Felice

Jason Felice is an XP developer from Cleveland, Ohio (USA).   He's been
coding since he discovered there's no level after 99 in Space Invaders on the
Atari 800, using Vim and hitting the \*nix man pages for twelve years, and
been around more environments (POSIX, Windows, mobile, embedded, web) than he
remembers.

He lives in @maker\_house, a house of nerds and makers in Cleveland's Ohio
City neighborhood. In previous lives, he was a game developer, a full-stack
consultant and the guy who used TDD, software kanban, and continuous
integration to turn around a large code base and a department.


![Profile picture](https://raw.github.com/eraserhd/rubyconfau-2014-cfp/jason_felice-complexity/talk-jason_felice-complexity/profile_picture.jpg)

- [My website](http://maitria.com)
- [My twitter](https://twitter.com/eraserhd)
- [Past talk slides](http://www.slideshare.net/eraserhd/complexity-multipliers)
